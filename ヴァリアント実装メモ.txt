
てかifからやろ。

(if cond exp1 exp2)
を
if cond then exp1 else exp2 fi
にする。

おーけーできました。
次！

で次。

defineが最終的にコードを全部生成する。
だからlambdaもletもグローバルを渡していく感じ。

いやこれlambdaに入る可能性あるもの全部がglabalも返さないといけなくなる。
いやーいけるか。defaultのfnが返してるから、そこでglabalも返せばいい。

いやこれEVALしたら絶対にexp_str + global_strが帰ってくるようにするってことだよな。

えーなんかめんどうだなぁーーーーどうしよーーーー
だってatomとかでも返さないといけなくなるぞこれ。

やっぱ正規表現でごり押し！でやるか...
<global>
struct variant {
  field type
  field valuet
}
</global>
みたいな感じで表記しておく。
defineはexp_strで、正規表現で<global></global>を見つけて、その中をコードの先頭に
置き換える、みたいなことをやる。


あーletのsetどーすっかなぁ。
いや変数名はそのままでvalueはできとうにオブジェクトいれりゃいい。
んー？これsetするやつのEVALできてんじゃん。
setはできてた。code_genでコンバートできてないだけ。
code_gen_letに渡すbindingsのvalueをastのままじゃなくてstringにしてから渡した。

ok、で。
let関数の初期化はとりあえず呼び出しのときに表示される文字がsetされてる。

(let ((| field void) v (check 1 2))
  (match v 
    (field (+ v 1))
    (void 1)
  )
)

でtypeは今見てないから、一行目はOK。
でlet_code_genだ。

とりあえず一回しかヴァリアントがない設定でやります。
いやせめてどこに一箇所でもいいようにやってくれ。

どうしよかなこれ。
今やってるのは、bindingsを前から3つずつみて処理。
てかこれあれだね、そもそもASTって配列にいろんな値入ってるのがありがたいね。
それもヴァリアント型といえるのかもしれん。てかリテラルから推測できるんだったら、
もはや型宣言いらなくないですか？？？？

これそもそも、

(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (+ v 1))

うむうむ、想定通りこの形。
[ [ Symbol(|), Symbol(field), Symbol(void) ],
  Symbol(v),
  'add(1, 2)' ]


うむOK。
これで宣言はOK。

いまやらなきゃあいつやるのレベルで最後マジ。

match、どうやるんだっけ？？
んー変数の型を取ってこないとダメ。
0->field
1->void
って感じにしてるから、パターンマッチングで(field)のときは中で0を使う、
(void)のときは中で1を使う
って感じにしないとダメ。
このリンクが大事なんだな。


(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void nil)))

評価された式のvを置換する必要がある。
/^v /
/ v$/
/ v /
この3種類だな。
変換してから評価したらenvにないってなるじゃん、って思ったけど、
あーーーーーーーーーーー天才
'v.value' = v
env.set(field, 'v.value')
でやれば完璧じゃないですか？？？

variant_envに設定すればいいんじゃねって思ったけど。
これlet_envってなんでわざわざ作ってんだっけ。スコープを作りたいから。
いや俺のコンパイラだと2文以上受けないから、いいんだけど、2文受けるときに、
ここ以外でv.valueが参照できたらまずいでしょ。

ん？結局これexpを置換しないといけなくないですか？
えー？
いやexpはASTになってるから置換簡単だわ。


[Symbol(+) Symbol(v), 1]
[Symbol(+) Symbol(v), [Symbol(+) Symbol(v) 2]
とかそういう感じ。

まぁ再帰でやったらできるわな。
const search = (ar) => {
  for(const i=0; i<ar.length)
}

Symbolって同じ文字に対して実行したら同じものになるんですか...?
ならなさそーな気がするんですが...
Symbol.for()はグローバルだからなる。
動作確認OK。

const replace_variant = (ar) => {
  return ar.map((e) => {
    if(Array.isArray(e)) return replace_variant(e);
    else if(e==Symbol.for('v')) return Symbol.for('v.value');
    else return e;
  });
};

const ar = [Symbol.for('+'), Symbol.for('v'), [Symbol.for('+'), Symbol.for('v'), 2]];

console.log(replace_variant(ar));



よし、matchの部分実証

(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void 1)))


↑これ、voidのときのexpが配列じゃないからmapでエラー出てた。
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void (+ 1 2))))
は通った。修正済み。

<global>
struct variant {
  field type
  field value
}
</global>
variant v = variant {type: 0, value: 0}
v = add(1, 2)
if v.type == 0 then (v.value + 1) else 1 fi

これが出力される。これであってますか？？


















