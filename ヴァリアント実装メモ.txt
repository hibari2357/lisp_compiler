
てかifからやろ。

(if cond exp1 exp2)
を
if cond then exp1 else exp2 fi
にする。

おーけーできました。
次！

で次。

defineが最終的にコードを全部生成する。
だからlambdaもletもグローバルを渡していく感じ。

いやこれlambdaに入る可能性あるもの全部がglabalも返さないといけなくなる。
いやーいけるか。defaultのfnが返してるから、そこでglabalも返せばいい。

いやこれEVALしたら絶対にexp_str + global_strが帰ってくるようにするってことだよな。

えーなんかめんどうだなぁーーーーどうしよーーーー
だってatomとかでも返さないといけなくなるぞこれ。

やっぱ正規表現でごり押し！でやるか...
<global>
struct variant {
  field type
  field valuet
}
</global>
みたいな感じで表記しておく。
defineはexp_strで、正規表現で<global></global>を見つけて、その中をコードの先頭に
置き換える、みたいなことをやる。


あーletのsetどーすっかなぁ。
いや変数名はそのままでvalueはできとうにオブジェクトいれりゃいい。
んー？これsetするやつのEVALできてんじゃん。
setはできてた。code_genでコンバートできてないだけ。
code_gen_letに渡すbindingsのvalueをastのままじゃなくてstringにしてから渡した。

ok、で。
let関数の初期化はとりあえず呼び出しのときに表示される文字がsetされてる。

(let ((| field void) v (check 1 2))
  (match v 
    (field (+ v 1))
    (void 1)
  )
)

でtypeは今見てないから、一行目はOK。
でlet_code_genだ。

とりあえず一回しかヴァリアントがない設定でやります。
いやせめてどこに一箇所でもいいようにやってくれ。

どうしよかなこれ。
今やってるのは、bindingsを前から3つずつみて処理。
てかこれあれだね、そもそもASTって配列にいろんな値入ってるのがありがたいね。
それもヴァリアント型といえるのかもしれん。てかリテラルから推測できるんだったら、
もはや型宣言いらなくないですか？？？？

これそもそも、

(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (+ v 1))

うむうむ、想定通りこの形。
[ [ Symbol(|), Symbol(field), Symbol(void) ],
  Symbol(v),
  'add(1, 2)' ]


うむOK。
これで宣言はOK。

いまやらなきゃあいつやるのレベルで最後マジ。

match、どうやるんだっけ？？
んー変数の型を取ってこないとダメ。
0->field
1->void
って感じにしてるから、パターンマッチングで(field)のときは中で0を使う、
(void)のときは中で1を使う
って感じにしないとダメ。
このリンクが大事なんだな。


(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void nil)))

評価された式のvを置換する必要がある。
/^v /
/ v$/
/ v /
この3種類だな。
変換してから評価したらenvにないってなるじゃん、って思ったけど、
あーーーーーーーーーーー天才
'v.value' = v
env.set(field, 'v.value')
でやれば完璧じゃないですか？？？

variant_envに設定すればいいんじゃねって思ったけど。
これlet_envってなんでわざわざ作ってんだっけ。スコープを作りたいから。
いや俺のコンパイラだと2文以上受けないから、いいんだけど、2文受けるときに、
ここ以外でv.valueが参照できたらまずいでしょ。

ん？結局これexpを置換しないといけなくないですか？
えー？
いやexpはASTになってるから置換簡単だわ。


[Symbol(+) Symbol(v), 1]
[Symbol(+) Symbol(v), [Symbol(+) Symbol(v) 2]
とかそういう感じ。

まぁ再帰でやったらできるわな。
const search = (ar) => {
  for(const i=0; i<ar.length)
}

Symbolって同じ文字に対して実行したら同じものになるんですか...?
ならなさそーな気がするんですが...
Symbol.for()はグローバルだからなる。
動作確認OK。

const replace_variant = (ar) => {
  return ar.map((e) => {
    if(Array.isArray(e)) return replace_variant(e);
    else if(e==Symbol.for('v')) return Symbol.for('v.value');
    else return e;
  });
};

const ar = [Symbol.for('+'), Symbol.for('v'), [Symbol.for('+'), Symbol.for('v'), 2]];

console.log(replace_variant(ar));



よし、matchの部分実証

(define (field add) (lambda (field a field b) (+ a b)))
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void 1)))


↑これ、voidのときのexpが配列じゃないからmapでエラー出てた。
(let ((| field void) v (add 1 2)) (match v (field (+ v 1)) (void (+ 1 2))))
は通った。修正済み。

<global>
struct variant {
  field type
  field value
}
</global>
variant v = variant {type: 0, value: 0}
v = add(1, 2)
if v.type == 0 then (v.value + 1) else 1 fi

これが出力される。これであってますか？？


はい、次
ヴァリアントを返す関数。
(define ((| field void) check)
  (lambda (field a field b)
    (if (= a b)
      (+ a b)
      nil
    )
  )
)

def check(field a, field b) -> (variant):
  res = if a == b then variant {type:0, value:(a + b)} else variant {type:1, value:0} fi
  return res

んーー
returnしてるvalueの型を見て、構造体のtypeを決めないといけないな。
とりあえず固定値でやる。


(define (field add) (lambda (field a field b) (+ a b))
これだとlabelは[field, add]
って感じ。

(define ((| field void) check))
これだとlabelは[[|, field, void] check]
って感じになる。

いやまってこれ、参ったぞ。lambdaがすでにexp_strを返してきてるぞこれ。
つまり、これに対して
  (lambda (field a field b)
    (if (= a b)
      (+ a b)
      nil
    )
  )

return if a == b then (a + b) else  fi
これを返してきてる。これをうまくパースして書き換える感じになるのか。
res = if a == b then variant {type:0, value:(a + b)} else variant {type:1, value:0} fi
んーまぁthenとelseの間を抜き出す、elseとfiの間を抜き出す、
valueに入れるってだけだからできるとは思う。

そのvalueの型見るじゃん、それでtype決めるじゃん、って感じだなこれ。
正規表現で間の文字の抜き出し型だな。
いやこれifとか関係なくreturnしてるやつを全パターン見る感じでしょこれ。
ん、いやそうか。1行しかうけつけてないから、最後の行が返り値。ifなら2つ見て、そうじゃなければ一つ見る。
変数コール(変数・関数)してたらそれの型。

よし。もう少し！
正味文章書くのはすぐにできる！！！
いやとりあえずifだけにしましょ...

あーglobalを外に出すのもあったな...
いやマジであともう少しなんだよな....

いまが一番やるとき
まずイメージを書く。

よし、よし、長かったが...
こんなに正規表現でゴリ押すものなのか...???
もっといい構成があるような気もするんだよなぁ。

return if a == b then (a + b) else null fi
return if a == b then variant {type: 0, value: (a + b)} else variant {type: 1, value: 0} fi



(define ((| field void) check) (lambda (field a field b) (if (= a b) (+ a b) nil)))

def check(field a, field b) -> (variant):
  return if (a == b) then variant {type: 0, value: (a + b)} else variant {type: 1, value: 0} fi




よし、次は型チェック！！！！！
・let宣言
宣言した型と、初期値のリテラルもしくはenv.getの型が同じか。
・define返り値
宣言した型と、返り値のリテラルもしくはenv.getの型が同じか。
・env.get関数/オペレータのパラメータ
こいつらはパラメータの型と、自身の型を持つ必要がある
呼び出し時のパラメータの型とパラメータの型が同じか。

どこでチェックするか？
こういう感じ。

env.data = {
  [key]:value,
  [key]:value,
}

って感じ。

env.data = {
  [key]:{
    value:'0',
    type:'field',
    params_type:[],
  },
}

みたいな感じにする。












